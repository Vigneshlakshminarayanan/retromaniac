{"ast":null,"code":"import _toConsumableArray from \"/Users/cognizanttechnologysolutions/Downloads/retro-main/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/cognizanttechnologysolutions/Downloads/retro-main/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _taggedTemplateLiteral from \"/Users/cognizanttechnologysolutions/Downloads/retro-main/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";\n\nvar _templateObject, _templateObject2, _templateObject3;\n\nimport * as React from \"react\";\nimport { gql } from \"apollo-boost\";\nimport { useQuery, useSubscription } from '@apollo/react-hooks';\nimport { Context } from './../Context';\nvar GET_CARDS = gql(_templateObject || (_templateObject = _taggedTemplateLiteral([\"\\n    query getCards {\\n        cards {\\n            id\\n            type\\n            userId\\n            content\\n        }\\n    }\\n\"])));\nvar CARD_ADDED_SUBSCRIPTION = gql(_templateObject2 || (_templateObject2 = _taggedTemplateLiteral([\"\\n    subscription onCardAdded($userId: String!, $type: String!) {\\n        cardAdded(userId: $userId, type: $type) {\\n            id\\n            type\\n            userId\\n        }\\n    }\\n\"])));\nvar CARD_DELETED_SUBSCRIPTION = gql(_templateObject3 || (_templateObject3 = _taggedTemplateLiteral([\"\\n    subscription onCardDeleted($type: String!) {\\n        cardDeleted(type: $type) {\\n            id\\n        }\\n    }\\n\"])));\n/**\n * Use this hook at the level of a column (to display the\n * cards of a certain type).\n *\n * This takes care of adding/removing cards in real-time\n * based on subscriptions. It also fetches them when first\n * mounting, in case the user arrives in the middle of a\n * game.\n *\n * Note that it is not responsible for _updating_ the cards;\n * each card should be responsible for its own updates\n * subscription. The reason for that is that we don't want\n * to update the whole tree on every single card update.\n */\n\nexport default function useCardsList(type) {\n  var _React$useState = React.useState(null),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      cards = _React$useState2[0],\n      setCards = _React$useState2[1];\n\n  var _React$useContext = React.useContext(Context),\n      user = _React$useContext.user; // First, we load any existing cards, in case the user that\n  // arrives is late to the game!\n\n\n  var _useQuery = useQuery(GET_CARDS),\n      getCards = _useQuery.data,\n      loading = _useQuery.loading,\n      refetch = _useQuery.refetch,\n      called = _useQuery.called;\n\n  React.useEffect(function () {\n    if (getCards && getCards.cards) {\n      setCards((getCards.cards || []).filter(function (card) {\n        return card.type === type;\n      }));\n    }\n  }, [getCards, type]); // We send the userId along with the subscription, because we\n  // don't want to return the cards that were created by the\n  // current user (and we'll filter on the server). Those cards\n  // are added when the user submits (see ColumnInput.tsx).\n\n  var _useSubscription = useSubscription(CARD_ADDED_SUBSCRIPTION, {\n    variables: {\n      type: type,\n      userId: user === null || user === void 0 ? void 0 : user.id\n    }\n  }),\n      cardAddedEv = _useSubscription.data;\n\n  React.useEffect(function () {\n    if (cardAddedEv) {\n      setCards(function (c) {\n        return [cardAddedEv.cardAdded].concat(_toConsumableArray(c || []));\n      });\n    }\n  }, [cardAddedEv]); // Same as CARD_ADDED_SUBSCRIPTION, except we don't need to send\n  // the userId: all cards will be deleted through here, including\n  // the current user's\n\n  var _useSubscription2 = useSubscription(CARD_DELETED_SUBSCRIPTION, {\n    variables: {\n      type: type\n    }\n  }),\n      cardDeletedEv = _useSubscription2.data;\n\n  React.useEffect(function () {\n    if (cardDeletedEv) {\n      setCards(function (c) {\n        return (c || []).filter(function (_ref) {\n          var id = _ref.id;\n          return id !== cardDeletedEv.cardDeleted.id;\n        });\n      });\n    }\n  }, [cardDeletedEv]);\n  return {\n    cards: cards,\n    setCards: setCards,\n    refetch: refetch,\n    loading: loading || !called\n  };\n}","map":{"version":3,"sources":["/Users/cognizanttechnologysolutions/Downloads/retro-main/src/Room/useCardsList.ts"],"names":["React","gql","useQuery","useSubscription","Context","GET_CARDS","CARD_ADDED_SUBSCRIPTION","CARD_DELETED_SUBSCRIPTION","useCardsList","type","useState","cards","setCards","useContext","user","getCards","data","loading","refetch","called","useEffect","filter","card","variables","userId","id","cardAddedEv","c","cardAdded","cardDeletedEv","cardDeleted"],"mappings":"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","sourcesContent":["import * as React from \"react\";\nimport { gql } from \"apollo-boost\";\nimport { useQuery, useSubscription } from '@apollo/react-hooks';\nimport { Context } from './../Context';\nimport CardType from './CardType';\n\ntype UseCardsList = {\n    cards: CardType[] | null\n    setCards: (cards: CardType[]) => void\n    refetch: () => void\n    loading: boolean\n};\n\nconst GET_CARDS = gql`\n    query getCards {\n        cards {\n            id\n            type\n            userId\n            content\n        }\n    }\n`;\n\nconst CARD_ADDED_SUBSCRIPTION = gql`\n    subscription onCardAdded($userId: String!, $type: String!) {\n        cardAdded(userId: $userId, type: $type) {\n            id\n            type\n            userId\n        }\n    }\n`;\n\nconst CARD_DELETED_SUBSCRIPTION = gql`\n    subscription onCardDeleted($type: String!) {\n        cardDeleted(type: $type) {\n            id\n        }\n    }\n`;\n\n/**\n * Use this hook at the level of a column (to display the\n * cards of a certain type).\n *\n * This takes care of adding/removing cards in real-time\n * based on subscriptions. It also fetches them when first\n * mounting, in case the user arrives in the middle of a\n * game.\n *\n * Note that it is not responsible for _updating_ the cards;\n * each card should be responsible for its own updates\n * subscription. The reason for that is that we don't want\n * to update the whole tree on every single card update.\n */\nexport default function useCardsList(type: string): UseCardsList {\n    const [cards, setCards] = React.useState<CardType[] | null>(null);\n\n    const { user } = React.useContext(Context);\n\n    // First, we load any existing cards, in case the user that\n    // arrives is late to the game!\n    const { data: getCards, loading, refetch, called } = useQuery(GET_CARDS);\n\n    React.useEffect(() => {\n        if (getCards && getCards.cards) {\n            setCards((getCards.cards || []).filter((card: any) => card.type === type));\n        }\n    }, [getCards, type]);\n\n    // We send the userId along with the subscription, because we\n    // don't want to return the cards that were created by the\n    // current user (and we'll filter on the server). Those cards\n    // are added when the user submits (see ColumnInput.tsx).\n    const { data: cardAddedEv } = useSubscription(CARD_ADDED_SUBSCRIPTION, {\n        variables: { type, userId: user?.id }\n    });\n\n    React.useEffect(() => {\n        if (cardAddedEv) {\n            setCards(c => [cardAddedEv.cardAdded, ...(c || [])]);\n        }\n    }, [cardAddedEv]);\n\n    // Same as CARD_ADDED_SUBSCRIPTION, except we don't need to send\n    // the userId: all cards will be deleted through here, including\n    // the current user's\n    const { data: cardDeletedEv } = useSubscription(CARD_DELETED_SUBSCRIPTION, {\n        variables: { type }\n    });\n\n    React.useEffect(() => {\n        if (cardDeletedEv) {\n            setCards(c => (c || []).filter(({ id }) => id !== cardDeletedEv.cardDeleted.id));\n        }\n    }, [cardDeletedEv]);\n\n    return {\n        cards,\n        setCards,\n        refetch,\n        loading: loading || !called\n    };\n}"]},"metadata":{},"sourceType":"module"}